/**
 * @fileoverview Firestore Security Rules for Prasiri Worship Manager.
 *
 * Core Philosophy: This ruleset enforces a hybrid access control model, combining user-ownership for personal data (TeamMember),
 * membership-based access for collaborative data (PeerGroup), and role-based access for global data (Songs, Services).
 *
 * Data Structure:
 * - /songs/{songId}: Publicly readable, but write access is restricted to authenticated users.
 * - /services/{serviceId}: Publicly readable, but write access is restricted to authenticated users.
 * - /team_members/{teamMemberId}: Strictly owner-only; only the user with the matching UID can read or write their own document.
 * - /schedules/{scheduleId}: Write access is restricted to authenticated users.
 * - /skill_focus_sessions/{skillFocusSessionId}: Write access is restricted to authenticated users.
 * - /peer_groups/{peerGroupId}: Accessible by members listed in the 'memberIds' array.
 * - /peer_groups/{peerGroupId}/contact_statuses/{contactStatusId}: Accessible by leaders of the peer group.
 * - /user_roles/{userId}: Only accessible by users with the admin role.
 *
 * Key Security Decisions:
 * - Listing of users (team_members) is disallowed for privacy.
 * - The existence of a document in /user_roles/{userId} implicitly grants the user an "admin" role.
 * - Ambiguous relationships default to strict owner-only access unless explicitly defined otherwise.
 *
 * Denormalization for Authorization:
 * - PeerGroup documents contain a 'memberIds' array for direct membership checks, avoiding costly 'get()' calls.
 * - TeamMember documents contain 'userId' matching the Firebase Auth UID, enabling simpler authorization checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows anyone to read songs, but restricts write access to authenticated users.
     * @path /songs/{songId}
     * @allow (get, list): if true
     * @allow (create): if isSignedIn()
     * @allow (update): if isSignedIn()
     * @allow (delete): if isSignedIn()
     * @deny (create): if false
     * @deny (update): if false
     * @deny (delete): if false
     * @principle Allows public read access while restricting writes to authenticated users.
     */
    match /songs/{songId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Allows anyone to read services, but restricts write access to authenticated users.
     * @path /services/{serviceId}
     * @allow (get, list): if true
     * @allow (create): if isSignedIn()
     * @allow (update): if isSignedIn()
     * @allow (delete): if isSignedIn()
     * @deny (create): if false
     * @deny (update): if false
     * @deny (delete): if false
     * @principle Allows public read access while restricting writes to authenticated users.
     */
    match /services/{serviceId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Allows a user to read/write their own team member profile.
     * @path /team_members/{teamMemberId}
     * @allow (get): if isOwner(teamMemberId)
     * @allow (create): if isOwner(teamMemberId)
     * @allow (update): if isExistingOwner(teamMemberId)
     * @allow (delete): if isExistingOwner(teamMemberId)
     * @allow (list): if false;
     * @deny (create): if request.resource.data.userId != request.auth.uid;
     * @deny (update): if request.resource.data.userId != resource.data.userId;
     * @principle Enforces strict user-ownership for team member profiles.
     */
    match /team_members/{teamMemberId} {
      allow get: if isOwner(teamMemberId);
      allow list: if false;
      allow create: if isOwner(teamMemberId);
      allow update: if isExistingOwner(teamMemberId) && (request.resource.data.userId == resource.data.userId);
      allow delete: if isExistingOwner(teamMemberId);
    }

    /**
     * @description Allows authenticated users to write to schedules.
     * @path /schedules/{scheduleId}
     * @allow (get): if isSignedIn()
     * @allow (create): if isSignedIn()
     * @allow (update): if isSignedIn()
     * @allow (delete): if isSignedIn()
     *  @allow (list): if isSignedIn()
     * @deny (create): if false
     * @deny (update): if false
     * @deny (delete): if false
     * @principle  Restricts writes to authenticated users.
     */
    match /schedules/{scheduleId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Allows authenticated users to write to skill focus sessions.
     * @path /skill_focus_sessions/{skillFocusSessionId}
     * @allow (get): if isSignedIn()
     * @allow (create): if isSignedIn()
     * @allow (update): if isSignedIn()
     * @allow (delete): if isSignedIn()
     *  @allow (list): if isSignedIn()
     * @deny (create): if false
     * @deny (update): if false
     * @deny (delete): if false
     * @principle  Restricts writes to authenticated users.
     */
    match /skill_focus_sessions/{skillFocusSessionId} {
      allow get: if isSignedIn();
       allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Allows members of a peer group to access the group.
     * @path /peer_groups/{peerGroupId}
     * @allow (get): if isInPeerGroup(peerGroupId)
     * @allow (create): if isSignedIn()
     * @allow (update): if isInPeerGroup(peerGroupId)
     * @allow (delete): if isInPeerGroup(peerGroupId)
     * @allow (list): if isSignedIn()
     * @deny (create): if false
     * @deny (update): if false
     * @deny (delete): if false
     * @principle Enforces membership-based access for peer groups.
     */
    match /peer_groups/{peerGroupId} {
      allow get: if isInPeerGroup(peerGroupId);
       allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isInPeerGroup(peerGroupId) && resource != null;
      allow delete: if isInPeerGroup(peerGroupId) && resource != null;
    }

    /**
     * @description Allows leaders of a peer group to access contact statuses.
     * @path /peer_groups/{peerGroupId}/contact_statuses/{contactStatusId}
     * @allow (get): if isPeerGroupLeader(peerGroupId)
     * @allow (create): if isPeerGroupLeader(peerGroupId)
     * @allow (update): if isPeerGroupLeader(peerGroupId)
     * @allow (delete): if isPeerGroupLeader(peerGroupId)
     *  @allow (list): if isPeerGroupLeader(peerGroupId)
     * @deny (create): if false
     * @deny (update): if false
     * @deny (delete): if false
     * @principle Enforces leader-only access for contact statuses within peer groups.
     */
    match /peer_groups/{peerGroupId}/contact_statuses/{contactStatusId} {
      allow get: if isPeerGroupLeader(peerGroupId);
      allow list: if isPeerGroupLeader(peerGroupId);
      allow create: if isPeerGroupLeader(peerGroupId);
      allow update: if isPeerGroupLeader(peerGroupId) && resource != null;
      allow delete: if isPeerGroupLeader(peerGroupId) && resource != null;
    }

    /**
     * @description Restricts access to user roles to admins.
     * @path /user_roles/{userId}
     * @allow (get): if isAdmin()
     * @allow (create): if isAdmin()
     * @allow (update): if isAdmin()
     * @allow (delete): if isAdmin()
     * @allow (list): if isAdmin()
     * @deny (create): if false
     * @deny (update): if false
     * @deny (delete): if false
     * @principle Enforces admin-only access for user roles.
     */
    match /user_roles/{userId} {
      allow get: if isAdmin();
       allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    // ---- Helper functions ----

    /**
     * @description Checks if the user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the requesting user is the owner of the document.
     * @param {string} userId The user ID to check against.
     * @return {bool} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the requesting user is the owner of the document and the document exists.
     * @param {string} userId The user ID to check against.
     * @return {bool} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the requesting user is a member of the peer group.
     * @param {string} peerGroupId The peer group ID.
     * @return {bool} True if the user is a member, false otherwise.
     */
    function isInPeerGroup(peerGroupId) {
      return isSignedIn() && peerGroupId != null && request.auth.uid in get(/databases/$(database)/documents/peer_groups/$(peerGroupId)).data.memberIds;
    }

    /**
     * @description Checks if the requesting user is the leader of the peer group.
     * @param {string} peerGroupId The peer group ID.
     * @return {bool} True if the user is the leader, false otherwise.
     */
    function isPeerGroupLeader(peerGroupId) {
      return isSignedIn() && peerGroupId != null && request.auth.uid == get(/databases/$(database)/documents/peer_groups/$(peerGroupId)).data.leaderId;
    }

    /**
     * @description Checks if the requesting user is an admin.
     * @return {bool} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/user_roles/$(request.auth.uid));
    }
  }
}