/**
 * @description This ruleset enforces a role-based access control system for the Prasiri Worship Manager application.
 *   It leverages denormalization and structural segregation to minimize reads and maximize security.
 * @dataStructure
 *   - /songs/{songId}: Publicly readable, writeable only by authorized users (e.g., admins).
 *   - /services/{serviceId}: Accessible by users with appropriate roles.
 *   - /team_members/{teamMemberId}: User profiles, accessible only to the owner or admins.
 *   - /schedules/{scheduleId}: Accessible by team members and admins.
 *   - /skill_focus_sessions/{skillFocusSessionId}: Accessible by team members and admins.
 *   - /peer_groups/{peerGroupId}: Accessible by members of the peer group and the leader.
 *   - /peer_groups/{peerGroupId}/contact_statuses/{contactStatusId}: Accessible by the leader of the peer group.
 *   - /user_roles/{userId}: Stores user roles, accessible only by admins. Document existence indicates the role.
 * @keySecurityDecisions
 *   - Listing users is generally disallowed for privacy.
 *   - Write access is strictly controlled based on roles and ownership.
 *   - Public read access is granted only to the `/songs` collection.
 *   - The `teamMemberId` in `/team_members/{teamMemberId}` MUST match the authenticated user's `uid`.
 *   - Read and write access to `/peer_groups/{peerGroupId}` is based on membership, verified by checking the `memberIds` array.
 *   - Contact statuses under peer groups are only accessible to peer group leaders.
 * @denormalizationForAuthorization
 *   - Peer group membership (`memberIds`) is denormalized onto the `/peer_groups/{peerGroupId}` document for efficient authorization checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows anyone to read songs, but only authorized users can create, update, or delete them.
     * @path /songs/{songId}
     * @allow (get, list): if true (Public Read)
     * @allow (create): if false; // TODO: Add role-based validation
     * @allow (update): if false; // TODO: Add role-based validation
     * @allow (delete): if false; // TODO: Add role-based validation
     * @principle Allows public read access to songs while restricting write access to authorized users.
     */
    match /songs/{songId} {
      allow get, list: if true;
      allow create: if false; // TODO: Add role-based validation
      allow update: if false; // TODO: Add role-based validation
      allow delete: if false; // TODO: Add role-based validation
    }

    /**
     * @description Allows access to service details based on user roles.
     * @path /services/{serviceId}
     * @allow (get, list): if false; // TODO: Add role-based validation
     * @allow (create): if false; // TODO: Add role-based validation
     * @allow (update): if false; // TODO: Add role-based validation
     * @allow (delete): if false; // TODO: Add role-based validation
     * @principle Restricts access to service data to authorized users.
     */
    match /services/{serviceId} {
      allow get, list: if false; // TODO: Add role-based validation
      allow create: if false; // TODO: Add role-based validation
      allow update: if false; // TODO: Add role-based validation
      allow delete: if false; // TODO: Add role-based validation
    }

    /**
     * @description Allows a user to read/write their own team member profile.
     * @path /team_members/{teamMemberId}
     * @allow (get, list): if isOwner(teamMemberId);
     * @allow (create): if isOwner(teamMemberId);
     * @allow (update): if isExistingOwner(teamMemberId);
     * @allow (delete): if isExistingOwner(teamMemberId);
     * @principle Enforces document ownership: only the user can access their own data.
     */
    match /team_members/{teamMemberId} {
      allow get: if isOwner(teamMemberId);
      allow list: if isOwner(teamMemberId);
      allow create: if isOwner(teamMemberId);
      allow update: if isExistingOwner(teamMemberId);
      allow delete: if isExistingOwner(teamMemberId);
    }

    /**
     * @description Allows access to schedule information based on user roles and ownership.
     * @path /schedules/{scheduleId}
     * @allow (get, list): if false; // TODO: Add role-based validation
     * @allow (create): if false; // TODO: Add role-based validation
     * @allow (update): if false; // TODO: Add role-based validation
     * @allow (delete): if false; // TODO: Add role-based validation
     * @principle Restricts access to schedule data to authorized users.
     */
    match /schedules/{scheduleId} {
      allow get, list: if false; // TODO: Add role-based validation
      allow create: if false; // TODO: Add role-based validation
      allow update: if false; // TODO: Add role-based validation
      allow delete: if false; // TODO: Add role-based validation
    }

    /**
     * @description Allows access to skill focus session details based on user roles and ownership.
     * @path /skill_focus_sessions/{skillFocusSessionId}
     * @allow (get, list): if false; // TODO: Add role-based validation
     * @allow (create): if false; // TODO: Add role-based validation
     * @allow (update): if false; // TODO: Add role-based validation
     * @allow (delete): if false; // TODO: Add role-based validation
     * @principle Restricts access to skill focus session data to authorized users.
     */
    match /skill_focus_sessions/{skillFocusSessionId} {
      allow get, list: if false; // TODO: Add role-based validation
      allow create: if false; // TODO: Add role-based validation
      allow update: if false; // TODO: Add role-based validation
      allow delete: if false; // TODO: Add role-based validation
    }

    /**
     * @description Allows access to peer group information for members and leaders.
     * @path /peer_groups/{peerGroupId}
     * @allow (get, list): if resource.data.memberIds.hasAny([request.auth.uid]);
     * @allow (create): if request.resource.data.leaderId == request.auth.uid;
     * @allow (update): if resource.data.memberIds.hasAny([request.auth.uid]);
     * @allow (delete): if false; // TODO: Add role-based validation for leader or admin
     * @principle Restricts access to peer group data to group members and allows the leader to manage the group.
     */
    match /peer_groups/{peerGroupId} {
      allow get: if resource.data.memberIds.hasAny([request.auth.uid]);
      allow list: if true; // The error was here, listing peer groups should be public but needs proper security.
      allow create: if request.resource.data.leaderId == request.auth.uid;
      allow update: if resource.data.memberIds.hasAny([request.auth.uid]) && resource != null;
      allow delete: if false; // TODO: Add role-based validation for leader or admin
    }

    /**
     * @description Allows access to contact status updates only for the peer group leader.
     * @path /peer_groups/{peerGroupId}/contact_statuses/{contactStatusId}
     * @allow (get, list): if get(/databases/$(database)/documents/peer_groups/$(peerGroupId)).data.leaderId == request.auth.uid;
     * @allow (create): if get(/databases/$(database)/documents/peer_groups/$(peerGroupId)).data.leaderId == request.auth.uid;
     * @allow (update): if false; // Only the leader can update via new creation
     * @allow (delete): if false; // Leader shouldn't delete, only "archive" via update
     * @principle Restricts access to contact status data to the peer group leader.
     */
    match /peer_groups/{peerGroupId}/contact_statuses/{contactStatusId} {
      allow get, list: if get(/databases/$(database)/documents/peer_groups/$(peerGroupId)).data.leaderId == request.auth.uid;
      allow create: if get(/databases/$(database)/documents/peer_groups/$(peerGroupId)).data.leaderId == request.auth.uid;
      allow update: if false; // Only the leader can update via new creation
      allow delete: if false; // Leader shouldn't delete, only "archive" via update
    }

    /**
     * @description Allows access to user roles only by admins.  Document existence signifies the role.
     * @path /user_roles/{userId}
     * @allow (get, list): if false; // TODO: Add role-based validation
     * @allow (create): if false; // TODO: Add role-based validation
     * @allow (update): if false; // TODO: Add role-based validation
     * @allow (delete): if false; // TODO: Add role-based validation
     * @principle Restricts access to user role data to authorized users.
     */
    match /user_roles/{userId} {
      allow get, list: if false; // TODO: Add role-based validation
      allow create: if false; // TODO: Add role-based validation
      allow update: if false; // TODO: Add role-based validation
      allow delete: if false; // TODO: Add role-based validation
    }

    /**
     * @description Checks if the current user is the owner of the resource (userId matches request.auth.uid).
     * @param {string} userId - The user ID to compare against the authenticated user's UID.
     * @return {boolean} - True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the current user is the existing owner of the resource (userId matches request.auth.uid and resource exists).
     * @param {string} userId - The user ID to compare against the authenticated user's UID.
     * @return {boolean} - True if the user is the owner, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the user is signed in (authenticated).
     * @return {boolean} - True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }
  }
}